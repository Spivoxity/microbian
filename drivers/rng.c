//
// Created by joshua on 22/05/23.
//
#include "microbian.h"
#include "hardware.h"

#define RNG_STR "RNG"
#define GET_RN 16
#define NO_CLIENT -1

/* NBUF -- size of input buffer.  Should be a power of 2. */
#define NBUF 256

static int RNG_TASK;
static int readers[NBUF] = {NO_CLIENT}; // Array to store client IDs waiting for random numbers



/* wrap -- reduce index to range [0..NBUF) */
#define wrap(x) ((x) & (NBUF-1))

/*
 * There is a single buffer containing random numbers generated by the RNG.
 * The buffer holds |n_avail| numbers that are available for processing.
 */
/* Input buffer */
static char rxbuf[NBUF];        /* Circular buffer for input */
static int rx_inp = 0;          /* In pointer */
static int rx_outp = 0;         /* Out pointer */
static int n_avail = 0;         /* Number of random bytes avail for input */

static void rng_interrupt_handler(void);
static void reply(void);

static message process_request(message *m, int client);

static void rng_task(int n)
{
    message m;
    int client;

    connect(RNG_IRQ);
    RNG_INTENSET = BIT(RNG_INT_VALRDY);

    RNG_START = 1;


/*
    priority(P_HANDLER);
*/
    enable_irq(RNG_IRQ);


    while (1) {
        receive(ANY, &m);
        client = m.sender;

        switch (m.type) {
            case INTERRUPT://from fictitious "HARDWARE" process
                rng_interrupt_handler();

                break;
            case GET_RN:
                m = process_request(&m, client);
                break;

            default:
                badmesg(m.type);
        }
        reply();
    }
}


static message process_request(message *m, int client) {

    if (n_avail > 0) {
        // If there are available random numbers, reply immediately
        m->int1 = rxbuf[rx_outp];
        m->type = REPLY;
        send(client, m);
        rx_outp = wrap(rx_outp + 1);
        n_avail--;
    } else {
        // If no random numbers available, add client to the readers array
        int i;
        for (i = 0; i < NBUF; i++) {
            if (readers[i] == NO_CLIENT) {
                readers[i] = client;
                break;
            }
        }
        if (i == NBUF) {
            panic("Maximum number of readers reached");
        }
    }
    return (*m);
}

void rng_init(void) {
/*
    intr_disable();
    RNG_STOP = 1;
    RNG_CONFIG = RNG_CONFIG_DERCEN; //disable digital error correction (if I'm not mistaken in what DERCEN is).
*/

    int i;
    for (i = 0; i < NBUF; i++) { readers[i] = NO_CLIENT; }



/*
    enable_irq(RNG_IRQ);
    intr_enable();
*/

    RNG_TASK = start(RNG_STR, rng_task, 0, 256);
}

static void send_to_reader(message * m, int reader);

static void reply(void) {
    message m;

    // Can we satisfy any readers?
    while (n_avail > 0) {
        int reader;

        for (reader = 0; reader < NBUF; reader++) {
            if (readers[reader] != NO_CLIENT) {
                send_to_reader(&m, reader);
                break;
            }
        }
        if (reader == NBUF) {
            // No more readers waiting
            break;
        }
    }




}

static void send_to_reader(message * m, int reader) {// Send random number to the reader
    /**
     * The reader only needs the int1 field of the message.
     */
    (*m).int1 = rxbuf[rx_outp];
    m->type=REPLY;
    send(readers[reader], m);
    rx_outp = wrap(rx_outp + 1);
    n_avail--;
    readers[reader] = NO_CLIENT;
}

static void new_number(unsigned char n);

static void rng_interrupt_handler(void) {

    if (RNG_VALRDY){
        unsigned char random_byte = RNG_VALUE;
        new_number(random_byte);
        RNG_VALRDY = 0;
        clear_pending(RNG_IRQ);
        enable_irq(RNG_IRQ);
    }

}

static void new_number(unsigned char n){
    /* Add character to line */
    if (n_avail == NBUF){
        ;//Just ignore this one. n_avail will get smaller whenever reply is called.
    }
    else {
        rxbuf[rx_inp] = n;
        rx_inp = wrap(rx_inp + 1);
        n_avail++;
    }
}

/* rng_get -- for clients to request a number */
unsigned char rng_get(void) {
    message m;
    m.type = GET_RN;
    sendrec(RNG_TASK, &m);
    return m.int1;
}
